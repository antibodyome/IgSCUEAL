LoadFunctionLibrary ("chooseGeneticCode", {"0":"Universal"});
LoadFunctionLibrary ("GrabBag");


function  _set_up_annotator () {
    if (_annotator_do_inverse_d) {
        // make inverted D
        _D_names = Rows (_D_sequences);
        _D_inverted = {};
        for (k = 0; k < Columns (_D_names); k+=1) {
            _D_inverted [_D_names[k]] = nucleotideReverseComplement (_D_sequences[_D_names[k]]);
        }    
    }

    curID   = 0;
    curCode = 1;
    breaks = (aa_breaks)*3+(-1);


    for (k = 0; k < IG_MRCA_sequence_length; k+=1) {
        _IG_nuc_annotation [k] = curCode;
        if (k == breaks[curID]) {
            curCode += 1;
            curID   += 1;
        }
    }
}

//--------------------------------------------------------------

function GetBestHomology (junction, d) {
    d_names = Rows (d);
    scores  = {};
    inStr   = {{junction, ""}};
    
    
    _dAlignOptions = alignOptions;
    _dAlignOptions ["SEQ_ALIGN_GAP_EXTEND"]  = 0;
    _dAlignOptions ["SEQ_ALIGN_GAP_EXTEND2"] = 0;
    _dAlignOptions ["SEQ_ALIGN_FRAMESHIFT"] = 100;
    _dAlignOptions ["SEQ_ALIGN_LOCAL_ALIGNMENT"] = 1;
    
    max_score = -1e100;
    
    for (d_allele = 0; d_allele < Abs (d); d_allele += 1) {
        inStr[1] = d[d_names[d_allele]];
        AlignSequences(aligned, inStr, _dAlignOptions);
        local_score = (aligned[0])[0]; // / Abs ( d[d_names[d_allele]]);
        
        //fprintf (stdout, d_names[d_allele], "=>", local_score, "\n");
        
        if (local_score > max_score) {
            max_score     = local_score;
            best_allele   = d_names[d_allele];
            best_sequence = (aligned[0])[1];
        }
    }    
    
    
    return {"SCORE" : max_score, 
            "ALLELE" : best_allele, 
            "SEQUENCE": best_sequence};
            
}

//--------------------------------------------------------------

function MapIGH (ref,qry)
{
    qryWithN = "";
    for (k = 0; k < Abs(qry); k+=1) {
        if (k % 3 == 0) {
            if (qry[k] == "-" && qry[k+1] == "-" && qry[k+2] == "-") {
                qryWithN += "---";
                k += 2;
                continue;
            }
        }
        if (qry[k] == "-") {
            qryWithN += "N";
        } else {
            qryWithN += qry[k];
        }
    }
	coords 	   = remapSequenceCoordinatesToReference (ref, qryWithN);
 	//fprintf ("/Volumes/sergei-raid/Desktop/igg.fas", CLEAR_FILE,">ref\n", ref, "\n>qry\n", qry, "\n>qryN\n", qryWithN, "\n");
	_IGHHReport = {};
	
	for (k = 0; k < Abs (_extraOutputColumns); k+=1) {
	    _IGHHReport[_extraOutputColumns[k]] = None;
	}
		
	_IGHHReport ["Mapped Read"] = qryWithN;
	_codonMappingIGHH = defineCodonToAA();
	currentL         = 0;
	// replace all triplet gaps with nothing
	// replace all remaining gaps with N
	qryNoGaps = (qry ^ {{"\\-\\-\\-",""}}) ^ {{"\\-","N"}};
	
	jRegionChunk = None;
	
	for (k = 1; k <= Abs (_features); k+=1) {
	
		thisSpan = coords[coords["_IG_nuc_annotation[_MATRIX_ELEMENT_VALUE_]==k__"]];
		thisSpanL = Columns(thisSpan);
		if (thisSpanL) {
			subSeq = qryNoGaps[currentL][currentL+thisSpanL-1];
			//fprintf (stdout, "\n\n", subSeq, "\n", translateCodonToAA (subSeq,_codonMappingIGHH,0), "\n");
			_IGHHReport [_features[k-1]] = subSeq;
			_IGHHReport [_features[k-1] + "_AA"] =  translateCodonToAA (subSeq,_codonMappingIGHH,0);
			
			if (_features[k-1] == "J") {
                if (None != jMotifFallBack) {
                    if (thisSpan[thisSpanL-1] >= jMotifFallBack) {
                        jRegionChunk = jMotifFallBack - thisSpan[0] - 1;
                        
                        if (jRegionChunk > 0) {
                            jRegionChunk = qryNoGaps[currentL][currentL + jRegionChunk];
                        }
                        else {
                            jRegionChunk = None;
                        }
                    }
                }
            }
            
			currentL += thisSpanL;
		}
		else {
			_IGHHReport [_features[k-1]] = "";
			_IGHHReport [_features[k-1] + "_AA"] = "";
		}
	}
	
	// pull out the junction 
	
	_IGHHReport["JUNCTION"]    = "";
	_IGHHReport["JUNCTION_AA"] = "";
	
    if (Abs (_IGHHReport ["FW3_AA"]) && Abs (_IGHHReport ["J_AA"])) {
	    // find the last "C" in FW3_AA
	    whereAreTheC = _IGHHReport ["FW3_AA"] || "C";
	    if (whereAreTheC[0] >= 0) {
	        whereAreTheC = whereAreTheC[Rows(whereAreTheC)-1];
	        // find the motif in "J"
	        jMotif = _IGHHReport ["J_AA"] $ jMotifRegExp;
	        if (jMotif[0] >= 0) {
	            jMotif = jMotif[0];
	            _IGHHReport ["JUNCTION"] = (_IGHHReport ["FW3"])[whereAreTheC*3][Abs(_IGHHReport ["FW3"])-1] + _IGHHReport["CDR3"] + (_IGHHReport["J"])[0][3*jMotif+2];
	            _IGHHReport ["JUNCTION_AA"] =  translateCodonToAA (_IGHHReport["JUNCTION"],_codonMappingIGHH,0);
	        } else {
	            if (None != jRegionChunk) {
	                _IGHHReport ["JUNCTION"] = (_IGHHReport ["FW3"])[whereAreTheC*3][Abs(_IGHHReport ["FW3"])-1] 
	                                           + _IGHHReport["CDR3"] + jRegionChunk;
	                _IGHHReport ["JUNCTION_AA"] =  translateCodonToAA (_IGHHReport["JUNCTION"],_codonMappingIGHH,0);
	            }
	        }
	    }
	}
	
	
	// try to pull out some "D" sequences
	
	
	if (Abs (_IGHHReport["JUNCTION"]) > 0) {
	    direct_d = GetBestHomology (_IGHHReport["JUNCTION"], _D_sequences);
	    _IGHHReport ["D_ALLELE"] = direct_d["ALLELE"];
	    _IGHHReport ["D"] = direct_d["SEQUENCE"];
	    _IGHHReport ["D_AA"] = translateCodonToAA (_IGHHReport ["D"],_codonMappingIGHH,0);
	    
	    if (_annotator_do_inverse_d) {
	        inverse_d = GetBestHomology (_IGHHReport["JUNCTION"], _D_inverted);
            _IGHHReport ["D/INV_ALLELE"] = inverse_d["ALLELE"];
            _IGHHReport ["D/INV"] = inverse_d["SEQUENCE"];
            _IGHHReport ["D/INV_AA"] = translateCodonToAA (inverse_d["SEQUENCE"],_codonMappingIGHH,0);	   
            _IGHHReport ["D/INV_SCORE"] = inverse_d ["SCORE"]; 
	        _IGHHReport ["D_SCORE"] = direct_d["SCORE"];
        }
	}
	
	/*_IGHHReport ["D_ALLELE"] = best_allele;
	_IGHHReport ["D"] = best_sequence;
	_IGHHReport ["D_AA"] = translateCodonToAA (best_sequence,_codonMappingIGHH,0);*/
	
	for (k = 0; k < Abs (qry); k+=1) {
		if (coords[k] < 0) {
			break;
		}
	}
	
	//fprintf (stdout, _IGHHReport, "\n");
	
	return _IGHHReport;
}

